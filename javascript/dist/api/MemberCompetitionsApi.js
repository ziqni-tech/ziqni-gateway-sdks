/**
 * Ziqni Gateway Services
 * These are the Gateway services to be used by customers.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@ziqni.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */
import ApiClient from "../ApiClient";
import ApiErrorResponse from '../model/ApiErrorResponse';
import Error from '../model/Error';
import MemberCompetitionResponse from '../model/MemberCompetitionResponse';
import MemberOptinResponse from '../model/MemberOptinResponse';
import MemberResponse from '../model/MemberResponse';
/**
* MemberCompetitions service.
* @module api/MemberCompetitionsApi
* @version 0.0.1
*/

export default class MemberCompetitionsApi {
  /**
  * Constructs a new MemberCompetitionsApi. 
  * @alias module:api/MemberCompetitionsApi
  * @class
  * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
  * default to {@link module:ApiClient#instance} if unspecified.
  */
  constructor(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;
  }
  /**
   * Callback function to receive the result of the checkMemberOptinStatus operation.
   * @callback module:api/MemberCompetitionsApi~checkMemberOptinStatusCallback
   * @param {String} error Error message, if any.
   * @param {module:model/MemberResponse} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * Returns details if the member has opted in
   * Check if a member is opted into a Competition using a Member Id.
   * @param {String} X_API_KEY Your unique API key
   * @param {String} spaceName This is the space name which is linked to the account
   * @param {String} memberId Id of a Member
   * @param {String} competitionId Id of a competition
   * @param {module:api/MemberCompetitionsApi~checkMemberOptinStatusCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/MemberResponse}
   */


  checkMemberOptinStatus(X_API_KEY, spaceName, memberId, competitionId, callback) {
    let postBody = null; // verify the required parameter 'X_API_KEY' is set

    if (X_API_KEY === undefined || X_API_KEY === null) {
      throw new Error("Missing the required parameter 'X_API_KEY' when calling checkMemberOptinStatus");
    } // verify the required parameter 'spaceName' is set


    if (spaceName === undefined || spaceName === null) {
      throw new Error("Missing the required parameter 'spaceName' when calling checkMemberOptinStatus");
    } // verify the required parameter 'memberId' is set


    if (memberId === undefined || memberId === null) {
      throw new Error("Missing the required parameter 'memberId' when calling checkMemberOptinStatus");
    } // verify the required parameter 'competitionId' is set


    if (competitionId === undefined || competitionId === null) {
      throw new Error("Missing the required parameter 'competitionId' when calling checkMemberOptinStatus");
    }

    let pathParams = {
      'spaceName': spaceName,
      'memberId': memberId,
      'competitionId': competitionId
    };
    let queryParams = {};
    let headerParams = {
      'X-API-KEY': X_API_KEY
    };
    let formParams = {};
    let authNames = ['apiKey'];
    let contentTypes = [];
    let accepts = ['application/json'];
    let returnType = MemberResponse;
    return this.apiClient.callApi('/api/v1/{spaceName}/members/{memberId}/competitions/{competitionId}/entrants', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null, callback);
  }
  /**
   * Callback function to receive the result of the checkMemberOptinStatusByRefId operation.
   * @callback module:api/MemberCompetitionsApi~checkMemberOptinStatusByRefIdCallback
   * @param {String} error Error message, if any.
   * @param {module:model/MemberResponse} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * Returns details if the member has opted in
   * Check if a member is opted into a Competition using a Member Id.
   * @param {String} X_API_KEY Your unique API key
   * @param {String} spaceName This is the space name which is linked to the account
   * @param {String} memberRefId Reference Id of a Member
   * @param {String} competitionId Id of a competition
   * @param {module:api/MemberCompetitionsApi~checkMemberOptinStatusByRefIdCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/MemberResponse}
   */


  checkMemberOptinStatusByRefId(X_API_KEY, spaceName, memberRefId, competitionId, callback) {
    let postBody = null; // verify the required parameter 'X_API_KEY' is set

    if (X_API_KEY === undefined || X_API_KEY === null) {
      throw new Error("Missing the required parameter 'X_API_KEY' when calling checkMemberOptinStatusByRefId");
    } // verify the required parameter 'spaceName' is set


    if (spaceName === undefined || spaceName === null) {
      throw new Error("Missing the required parameter 'spaceName' when calling checkMemberOptinStatusByRefId");
    } // verify the required parameter 'memberRefId' is set


    if (memberRefId === undefined || memberRefId === null) {
      throw new Error("Missing the required parameter 'memberRefId' when calling checkMemberOptinStatusByRefId");
    } // verify the required parameter 'competitionId' is set


    if (competitionId === undefined || competitionId === null) {
      throw new Error("Missing the required parameter 'competitionId' when calling checkMemberOptinStatusByRefId");
    }

    let pathParams = {
      'spaceName': spaceName,
      'memberRefId': memberRefId,
      'competitionId': competitionId
    };
    let queryParams = {};
    let headerParams = {
      'X-API-KEY': X_API_KEY
    };
    let formParams = {};
    let authNames = ['apiKey'];
    let contentTypes = [];
    let accepts = ['application/json'];
    let returnType = MemberResponse;
    return this.apiClient.callApi('/api/v1/{spaceName}/members/reference/{memberRefId}/competitions/{competitionId}/entrants', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null, callback);
  }
  /**
   * Callback function to receive the result of the getCompetitionsByMemberRefId operation.
   * @callback module:api/MemberCompetitionsApi~getCompetitionsByMemberRefIdCallback
   * @param {String} error Error message, if any.
   * @param {module:model/MemberCompetitionResponse} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * Returns a list of competitions for a specific member
   * Returns a list of competitions that the member can participate in (filtering will be done automatically for member group eligibility).  `The default behaviour of a response is that the competitions that are in Ready, Active or Finished state AND are eligible for ALL and eligible for the member Id requested will be returned unless queried otherwise.`  This assumes that competitions have first been created using the web console otherwise no data will be returned and the value of the \"totalRecordsFound\" variable in metadata will be 0.  GET responses can be filtered out based on the competition parameters to narrow down the results.  The denser the queryable URL the more precise the response will be.   Sort by fields is limited to: * created (DateTime of the competition creation) * label (the label of the competition) * scheduled start and end DateTime * actual start and end DateTime * status code that indicates the status of the competition  Example:  ?_sortByFields=created  ?_sortByFields=label  ?_sortByFields=options.scheduledDates.start  ?_sortByFields=options.scheduledDates.end  ?_sortByFields=options.actualDates.start  ?_sortByFields=options.actualDates.end  ?_sortByFields=statusCode
   * @param {String} X_API_KEY Your unique API key
   * @param {String} spaceName This is the space name which is linked to the account
   * @param {String} memberRefId Reference Id of a Member
   * @param {Object} opts Optional parameters
   * @param {Array.<String>} opts.id The unique identifiers of the resources
   * @param {Number} opts.limit Used for pagination. Setting the limit value will cause the system to limit the number of records returned to the specified number.
   * @param {Number} opts.skip Used for pagination. Setting the skip value will cause the system to return records from the specified position onwards.  EXAMPLE below returns the results for requested resource without skipping any records  <url>?_limit=5&_skip=0  EXAMPLE below returns the results for requested resource after skipping the first 10 records  `<url>?_limit=5&_skip=10`
   * @param {String} opts.sortByFields Enables sorting of results based on fields and order specified.  Supported ordering  `asc, desc`   Usage syntax  `_sortByFields=<field-to-sort-on>:<order>`   EXAMPLE The query will return data sorted by transactionTimestamp in descending order  `<url>?_sortByFields=transactionTimestamp:desc,created:asc`
   * @param {String} opts.include Allows you to add the products and metadata objects to the response. Case sensitive
   * @param {String} opts.lang Allows you to preview the label, description and terms and conditions of the competition in a requested language. Case sensitive
   * @param {String} opts. Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  Single equals sign usage has two types of applications in formulating API queries - * assigning values to predefined/reserved parameters like _skip, _limit, _lang, _sortByFields, _uomKey, _include * assigning values to model based parameters (Example name, transactionTimestamp, options.limitEntrantsTo etc.)  EXAMPLE below returns all competitions in \"Ready\" or \"Active\" state that have either a group1 or group2 entrant limitation  `<url>/competitions?_skip=0&_limit=100&status=Ready,Active&options.limitEntrantsTo=group1,group2`
   * @param {String} opts.2 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  Single equals sign usage has two types of applications in formulating API queries - * assigning values to predefined/reserved parameters like _skip, _limit, _lang, _sortByFields, _uomKey, _include * assigning values to model based parameters (Example name, transactionTimestamp, options.limitEntrantsTo etc.)  EXAMPLE below returns all competitions in \"Ready\" state only that have either a group1 or group2 entrant limitation  `<url>/competitions?_skip=0&_limit=100&status==Ready&options.limitEntrantsTo=group1,group2`
   * @param {String} opts.3 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The less than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or less than the specified field value.  EXAMPLE below returns all the data which was uploaded before 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp<=2021-02-09T17:38:08.328`
   * @param {String} opts.4 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The less than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or less than the specified field value.  EXAMPLE below returns all the data which were uploaded before 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp<==2021-02-09T17:38:08.328`
   * @param {String} opts.5 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The greater than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or greater than the specified field value.  EXAMPLE below returns all the data which were uploaded after 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp=>2021-02-09T17:38:08.328`
   * @param {String} opts.6 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The greater than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or greater than the specified field value.  EXAMPLE below returns all the data which were uploaded after 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp==>2021-02-09T17:38:08.328`
   * @param {String} opts.optionsActualDatesEnd Start and end time of when it actually ended  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.actualDates.end=search_DateTime`
   * @param {String} opts.actualEnd Start and end time of when it actually ended  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?actualEnd=search_DateTime`
   * @param {String} opts.productsProductRefId Search by products reference Id and products metadata. Case sensitive.  `?products.productRefId=search_word`
   * @param {String} opts.productRefId Search by products reference Id and products metadata. Case sensitive.  `?productRefId=search_word`
   * @param {String} opts.optionsProductsMetadataKey Search by products reference Id and products metadata. Case sensitive.  `?options.products.metadata.key=search_word`
   * @param {String} opts.optionsProductsMetadataValue Search by products reference Id and products metadata. Case sensitive.  `?options.products.metadata.value=search_word`
   * @param {String} opts.optionsProductsProductRefId Search by products reference Id and products metadata. Case sensitive.  `?options.products.productRefId=search_word`
   * @param {String} opts.status The status of the competition. Case sensitive. Supported values - `Unknown` `Deleting` `Deleted` `Draft` `Template` `Preparing` `Ready` `Starting` `Active` `Finishing` `Finished` `Cancelling` `Cancelled`
   * @param {Number} opts.statusCode The status code of the competition. Numbers only.  Supported values:  -3 (Unknown)  -2 (Deleting)  -1 (Deleted)  0 (Draft)  1 (Template)  2 (Preparing)  3 (Ready)  4 (Starting)  5 (Active)  6 (Finishing)  7 (Finished)  8 (Cancelling)  9 (Cancelled) 
   * @param {Array.<String>} opts.optionsLimitEntrantsTo The value is the member group that you are searching for that is eligible to participate. Case sensitive.  `?options.limitEntrantsTo=search_word`
   * @param {Array.<String>} opts.limitEntrantsTo The value is the member group that you are searching for that is eligible to participate. Case sensitive.  `?limitEntrantsTo=search_word`
   * @param {String} opts.optionsScheduledDatesStart Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.scheduledDates.start=search_DateTime`
   * @param {String} opts.scheduledStart Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?scheduledStart=search_DateTime`
   * @param {String} opts.optionsScheduledDatesEnd Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.scheduledDates.end=search_DateTime`
   * @param {String} opts.scheduledEnd Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?scheduledStart=search_DateTime`
   * @param {String} opts.optionsActualDatesStart Start and end time of when it actually started  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.actualDates.start=search_DateTime`
   * @param {String} opts.actualStart Start and end time of when it actually started  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?actualStart=search_DateTime`
   * @param {module:api/MemberCompetitionsApi~getCompetitionsByMemberRefIdCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/MemberCompetitionResponse}
   */


  getCompetitionsByMemberRefId(X_API_KEY, spaceName, memberRefId, opts, callback) {
    opts = opts || {};
    let postBody = null; // verify the required parameter 'X_API_KEY' is set

    if (X_API_KEY === undefined || X_API_KEY === null) {
      throw new Error("Missing the required parameter 'X_API_KEY' when calling getCompetitionsByMemberRefId");
    } // verify the required parameter 'spaceName' is set


    if (spaceName === undefined || spaceName === null) {
      throw new Error("Missing the required parameter 'spaceName' when calling getCompetitionsByMemberRefId");
    } // verify the required parameter 'memberRefId' is set


    if (memberRefId === undefined || memberRefId === null) {
      throw new Error("Missing the required parameter 'memberRefId' when calling getCompetitionsByMemberRefId");
    }

    let pathParams = {
      'spaceName': spaceName,
      'memberRefId': memberRefId
    };
    let queryParams = {
      'id': this.apiClient.buildCollectionParam(opts['id'], 'multi'),
      '_limit': opts['limit'],
      '_skip': opts['skip'],
      '_sortByFields': opts['sortByFields'],
      '_include': opts['include'],
      '_lang': opts['lang'],
      '&#x3D;': opts[''],
      '&#x3D;&#x3D;': opts['2'],
      '&lt;&#x3D;': opts['3'],
      '&lt;&#x3D;&#x3D;': opts['4'],
      '&#x3D;&gt;': opts['5'],
      '&#x3D;&#x3D;&gt;': opts['6'],
      'options.actualDates.end': opts['optionsActualDatesEnd'],
      'actualEnd': opts['actualEnd'],
      'products.productRefId': opts['productsProductRefId'],
      'productRefId': opts['productRefId'],
      'options.products.metadata.key': opts['optionsProductsMetadataKey'],
      'options.products.metadata.value': opts['optionsProductsMetadataValue'],
      'options.products.productRefId': opts['optionsProductsProductRefId'],
      'status': opts['status'],
      'statusCode': opts['statusCode'],
      'options.limitEntrantsTo': this.apiClient.buildCollectionParam(opts['optionsLimitEntrantsTo'], 'multi'),
      'limitEntrantsTo': this.apiClient.buildCollectionParam(opts['limitEntrantsTo'], 'multi'),
      'options.scheduledDates.start': opts['optionsScheduledDatesStart'],
      'scheduledStart': opts['scheduledStart'],
      'options.scheduledDates.end': opts['optionsScheduledDatesEnd'],
      'scheduledEnd': opts['scheduledEnd'],
      'options.actualDates.start': opts['optionsActualDatesStart'],
      'actualStart': opts['actualStart']
    };
    let headerParams = {
      'X-API-KEY': X_API_KEY
    };
    let formParams = {};
    let authNames = ['apiKey'];
    let contentTypes = [];
    let accepts = ['application/json'];
    let returnType = MemberCompetitionResponse;
    return this.apiClient.callApi('/api/v1/{spaceName}/members/reference/{memberRefId}/competitions', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null, callback);
  }
  /**
   * Callback function to receive the result of the getMemberCompetitions operation.
   * @callback module:api/MemberCompetitionsApi~getMemberCompetitionsCallback
   * @param {String} error Error message, if any.
   * @param {module:model/MemberCompetitionResponse} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * Returns a list of competitions for a specific member
   * Returns a list of competitions that the member can participate in (filtering will be done automatically for member group eligibility).  `The default behaviour of a response is that the competitions that are in Ready, Active or Finished state AND are eligible for ALL and eligible for the member Id requested will be returned unless queried otherwise.`  This assumes that competitions have first been created using the web console otherwise no data will be returned and the value of the \"totalRecordsFound\" variable in metadata will be 0.  GET responses can be filtered out based on the competition parameters to narrow down the results.  The denser the queryable URL the more precise the response will be.   Sort by fields is limited to: * created (DateTime of the competition creation) * label (the label of the competition) * scheduled start and end DateTime * actual start and end DateTime * status code that indicates the status of the competition  Example:  ?_sortByFields=created  ?_sortByFields=label  ?_sortByFields=options.scheduledDates.start  ?_sortByFields=options.scheduledDates.end  ?_sortByFields=options.actualDates.start  ?_sortByFields=options.actualDates.end  ?_sortByFields=statusCode
   * @param {String} X_API_KEY Your unique API key
   * @param {String} spaceName This is the space name which is linked to the account
   * @param {String} memberId Id of a Member
   * @param {Object} opts Optional parameters
   * @param {Array.<String>} opts.id The unique identifiers of the resources
   * @param {Number} opts.limit Used for pagination. Setting the limit value will cause the system to limit the number of records returned to the specified number.
   * @param {Number} opts.skip Used for pagination. Setting the skip value will cause the system to return records from the specified position onwards.  EXAMPLE below returns the results for requested resource without skipping any records  <url>?_limit=5&_skip=0  EXAMPLE below returns the results for requested resource after skipping the first 10 records  `<url>?_limit=5&_skip=10`
   * @param {String} opts.sortByFields Enables sorting of results based on fields and order specified.  Supported ordering  `asc, desc`   Usage syntax  `_sortByFields=<field-to-sort-on>:<order>`   EXAMPLE The query will return data sorted by transactionTimestamp in descending order  `<url>?_sortByFields=transactionTimestamp:desc,created:asc`
   * @param {String} opts.include Allows you to add the products and metadata objects to the response. Case sensitive
   * @param {String} opts.lang Allows you to preview the label, description and terms and conditions of the competition in a requested language. Case sensitive
   * @param {String} opts. Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  Single equals sign usage has two types of applications in formulating API queries - * assigning values to predefined/reserved parameters like _skip, _limit, _lang, _sortByFields, _uomKey, _include * assigning values to model based parameters (Example name, transactionTimestamp, options.limitEntrantsTo etc.)  EXAMPLE below returns all competitions in \"Ready\" or \"Active\" state that have either a group1 or group2 entrant limitation  `<url>/competitions?_skip=0&_limit=100&status=Ready,Active&options.limitEntrantsTo=group1,group2`
   * @param {String} opts.2 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  Single equals sign usage has two types of applications in formulating API queries - * assigning values to predefined/reserved parameters like _skip, _limit, _lang, _sortByFields, _uomKey, _include * assigning values to model based parameters (Example name, transactionTimestamp, options.limitEntrantsTo etc.)  EXAMPLE below returns all competitions in \"Ready\" state only that have either a group1 or group2 entrant limitation  `<url>/competitions?_skip=0&_limit=100&status==Ready&options.limitEntrantsTo=group1,group2`
   * @param {String} opts.3 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The less than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or less than the specified field value.  EXAMPLE below returns all the data which was uploaded before 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp<=2021-02-09T17:38:08.328`
   * @param {String} opts.4 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The less than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or less than the specified field value.  EXAMPLE below returns all the data which were uploaded before 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp<==2021-02-09T17:38:08.328`
   * @param {String} opts.5 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The greater than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or greater than the specified field value.  EXAMPLE below returns all the data which were uploaded after 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp=>2021-02-09T17:38:08.328`
   * @param {String} opts.6 Single `=` sign usage will work as a `should/OR` action and `==` will work as a `must/AND` action  The greater than equal filter can be used on fields with a data type of integer, long, double, float, date, time or date-time. The filter will return all matching records that are equal to or greater than the specified field value.  EXAMPLE below returns all the data which were uploaded after 17:38 9th of February 2021 (defaults to 20 results).  `<url>events?transactionTimestamp==>2021-02-09T17:38:08.328`
   * @param {String} opts.optionsActualDatesEnd Start and end time of when it actually ended  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.actualDates.end=search_DateTime`
   * @param {String} opts.actualEnd Start and end time of when it actually ended  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?actualEnd=search_DateTime`
   * @param {String} opts.productsProductRefId Search by products reference Id and products metadata. Case sensitive.  `?products.productRefId=search_word`
   * @param {String} opts.productRefId Search by products reference Id and products metadata. Case sensitive.  `?productRefId=search_word`
   * @param {String} opts.optionsProductsMetadataKey Search by products reference Id and products metadata. Case sensitive.  `?options.products.metadata.key=search_word`
   * @param {String} opts.optionsProductsMetadataValue Search by products reference Id and products metadata. Case sensitive.  `?options.products.metadata.value=search_word`
   * @param {String} opts.optionsProductsProductRefId Search by products reference Id and products metadata. Case sensitive.  `?options.products.productRefId=search_word`
   * @param {String} opts.status The status of the competition. Case sensitive. Supported values - `Unknown` `Deleting` `Deleted` `Draft` `Template` `Preparing` `Ready` `Starting` `Active` `Finishing` `Finished` `Cancelling` `Cancelled`
   * @param {Number} opts.statusCode The status code of the competition. Numbers only.  Supported values:  -3 (Unknown)  -2 (Deleting)  -1 (Deleted)  0 (Draft)  1 (Template)  2 (Preparing)  3 (Ready)  4 (Starting)  5 (Active)  6 (Finishing)  7 (Finished)  8 (Cancelling)  9 (Cancelled) 
   * @param {Array.<String>} opts.optionsLimitEntrantsTo The value is the member group that you are searching for that is eligible to participate. Case sensitive.  `?options.limitEntrantsTo=search_word`
   * @param {Array.<String>} opts.limitEntrantsTo The value is the member group that you are searching for that is eligible to participate. Case sensitive.  `?limitEntrantsTo=search_word`
   * @param {String} opts.optionsScheduledDatesStart Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.scheduledDates.start=search_DateTime`
   * @param {String} opts.scheduledStart Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?scheduledStart=search_DateTime`
   * @param {String} opts.optionsScheduledDatesEnd Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.scheduledDates.end=search_DateTime`
   * @param {String} opts.scheduledEnd Start and end time of when it was scheduled  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?scheduledStart=search_DateTime`
   * @param {String} opts.optionsActualDatesStart Start and end time of when it actually started  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?options.actualDates.start=search_DateTime`
   * @param {String} opts.actualStart Start and end time of when it actually started  Supported DateTime patterns - * String = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss.SSS\" * String = \"yyyy-MM-dd'T'HH:mm:ssZ\" * String = \"yyyy-MM-dd'T'HH:mm:ss\" * String = \"yyyy-MM-dd'T'HH:mm\" * String = \"yyyy-MM-dd HH:mm:ss\" * String = \"yyyy-MM-dd HH:mm\" * String = \"yyyy/MM/dd HH:mm:ss\" * String = \"yyyy/MM/dd HH:mm\"  `?actualStart=search_DateTime`
   * @param {module:api/MemberCompetitionsApi~getMemberCompetitionsCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/MemberCompetitionResponse}
   */


  getMemberCompetitions(X_API_KEY, spaceName, memberId, opts, callback) {
    opts = opts || {};
    let postBody = null; // verify the required parameter 'X_API_KEY' is set

    if (X_API_KEY === undefined || X_API_KEY === null) {
      throw new Error("Missing the required parameter 'X_API_KEY' when calling getMemberCompetitions");
    } // verify the required parameter 'spaceName' is set


    if (spaceName === undefined || spaceName === null) {
      throw new Error("Missing the required parameter 'spaceName' when calling getMemberCompetitions");
    } // verify the required parameter 'memberId' is set


    if (memberId === undefined || memberId === null) {
      throw new Error("Missing the required parameter 'memberId' when calling getMemberCompetitions");
    }

    let pathParams = {
      'spaceName': spaceName,
      'memberId': memberId
    };
    let queryParams = {
      'id': this.apiClient.buildCollectionParam(opts['id'], 'multi'),
      '_limit': opts['limit'],
      '_skip': opts['skip'],
      '_sortByFields': opts['sortByFields'],
      '_include': opts['include'],
      '_lang': opts['lang'],
      '&#x3D;': opts[''],
      '&#x3D;&#x3D;': opts['2'],
      '&lt;&#x3D;': opts['3'],
      '&lt;&#x3D;&#x3D;': opts['4'],
      '&#x3D;&gt;': opts['5'],
      '&#x3D;&#x3D;&gt;': opts['6'],
      'options.actualDates.end': opts['optionsActualDatesEnd'],
      'actualEnd': opts['actualEnd'],
      'products.productRefId': opts['productsProductRefId'],
      'productRefId': opts['productRefId'],
      'options.products.metadata.key': opts['optionsProductsMetadataKey'],
      'options.products.metadata.value': opts['optionsProductsMetadataValue'],
      'options.products.productRefId': opts['optionsProductsProductRefId'],
      'status': opts['status'],
      'statusCode': opts['statusCode'],
      'options.limitEntrantsTo': this.apiClient.buildCollectionParam(opts['optionsLimitEntrantsTo'], 'multi'),
      'limitEntrantsTo': this.apiClient.buildCollectionParam(opts['limitEntrantsTo'], 'multi'),
      'options.scheduledDates.start': opts['optionsScheduledDatesStart'],
      'scheduledStart': opts['scheduledStart'],
      'options.scheduledDates.end': opts['optionsScheduledDatesEnd'],
      'scheduledEnd': opts['scheduledEnd'],
      'options.actualDates.start': opts['optionsActualDatesStart'],
      'actualStart': opts['actualStart']
    };
    let headerParams = {
      'X-API-KEY': X_API_KEY
    };
    let formParams = {};
    let authNames = ['apiKey'];
    let contentTypes = [];
    let accepts = ['application/json'];
    let returnType = MemberCompetitionResponse;
    return this.apiClient.callApi('/api/v1/{spaceName}/members/{memberId}/competitions', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null, callback);
  }
  /**
   * Callback function to receive the result of the optinMemberToCompetition operation.
   * @callback module:api/MemberCompetitionsApi~optinMemberToCompetitionCallback
   * @param {String} error Error message, if any.
   * @param {module:model/MemberOptinResponse} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * Opt in a member in a competition
   * Allows a member to opt-in into an existing Competition using an existing Member Id.  Use `/api/v1/:space/members/:memberId/competition/:competitionId/entrants` or `/api/v1/:space/members/reference/:memberRefId/competition/:competitionId/entrants`  API endpoint to determine if a Member is already Opted in to a Competition.
   * @param {String} X_API_KEY Your unique API key
   * @param {String} spaceName This is the space name which is linked to the account
   * @param {String} memberId Id of a Member
   * @param {String} competitionId Id of a competition
   * @param {module:api/MemberCompetitionsApi~optinMemberToCompetitionCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/MemberOptinResponse}
   */


  optinMemberToCompetition(X_API_KEY, spaceName, memberId, competitionId, callback) {
    let postBody = null; // verify the required parameter 'X_API_KEY' is set

    if (X_API_KEY === undefined || X_API_KEY === null) {
      throw new Error("Missing the required parameter 'X_API_KEY' when calling optinMemberToCompetition");
    } // verify the required parameter 'spaceName' is set


    if (spaceName === undefined || spaceName === null) {
      throw new Error("Missing the required parameter 'spaceName' when calling optinMemberToCompetition");
    } // verify the required parameter 'memberId' is set


    if (memberId === undefined || memberId === null) {
      throw new Error("Missing the required parameter 'memberId' when calling optinMemberToCompetition");
    } // verify the required parameter 'competitionId' is set


    if (competitionId === undefined || competitionId === null) {
      throw new Error("Missing the required parameter 'competitionId' when calling optinMemberToCompetition");
    }

    let pathParams = {
      'spaceName': spaceName,
      'memberId': memberId,
      'competitionId': competitionId
    };
    let queryParams = {};
    let headerParams = {
      'X-API-KEY': X_API_KEY
    };
    let formParams = {};
    let authNames = ['apiKey'];
    let contentTypes = [];
    let accepts = ['application/json'];
    let returnType = MemberOptinResponse;
    return this.apiClient.callApi('/api/v1/{spaceName}/members/{memberId}/competitions/{competitionId}/optin', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null, callback);
  }
  /**
   * Callback function to receive the result of the optinMemberToCompetitionByRefId operation.
   * @callback module:api/MemberCompetitionsApi~optinMemberToCompetitionByRefIdCallback
   * @param {String} error Error message, if any.
   * @param {module:model/MemberOptinResponse} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * Opt in a member in a competition
   * Allows a member to opt-in into an existing Competition using an existing Member Id.  Use `/api/v1/:space/members/:memberId/competition/:competitionId/entrants` or `/api/v1/:space/members/reference/:memberRefId/competition/:competitionId/entrants`  API endpoint to determine if a Member is already Opted in to a Competition.
   * @param {String} X_API_KEY Your unique API key
   * @param {String} spaceName This is the space name which is linked to the account
   * @param {String} memberRefId Reference Id of a Member
   * @param {String} competitionId Id of a competition
   * @param {module:api/MemberCompetitionsApi~optinMemberToCompetitionByRefIdCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/MemberOptinResponse}
   */


  optinMemberToCompetitionByRefId(X_API_KEY, spaceName, memberRefId, competitionId, callback) {
    let postBody = null; // verify the required parameter 'X_API_KEY' is set

    if (X_API_KEY === undefined || X_API_KEY === null) {
      throw new Error("Missing the required parameter 'X_API_KEY' when calling optinMemberToCompetitionByRefId");
    } // verify the required parameter 'spaceName' is set


    if (spaceName === undefined || spaceName === null) {
      throw new Error("Missing the required parameter 'spaceName' when calling optinMemberToCompetitionByRefId");
    } // verify the required parameter 'memberRefId' is set


    if (memberRefId === undefined || memberRefId === null) {
      throw new Error("Missing the required parameter 'memberRefId' when calling optinMemberToCompetitionByRefId");
    } // verify the required parameter 'competitionId' is set


    if (competitionId === undefined || competitionId === null) {
      throw new Error("Missing the required parameter 'competitionId' when calling optinMemberToCompetitionByRefId");
    }

    let pathParams = {
      'spaceName': spaceName,
      'memberRefId': memberRefId,
      'competitionId': competitionId
    };
    let queryParams = {};
    let headerParams = {
      'X-API-KEY': X_API_KEY
    };
    let formParams = {};
    let authNames = ['apiKey'];
    let contentTypes = [];
    let accepts = ['application/json'];
    let returnType = MemberOptinResponse;
    return this.apiClient.callApi('/api/v1/{spaceName}/members/reference/{memberRefId}/competitions/{competitionId}/optin', 'GET', pathParams, queryParams, headerParams, formParams, postBody, authNames, contentTypes, accepts, returnType, null, callback);
  }

}